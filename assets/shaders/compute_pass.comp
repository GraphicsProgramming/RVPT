#version 450
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : require

#define PI 3.1415
#define RAY_MIN_DIST 0.01

layout(local_size_x = 16, local_size_y = 16) in;
layout(binding = 0, rgba8) uniform writeonly image2D result_image;
layout(binding = 1) uniform Camera
{
    vec3 origin;
    vec3 center;
    vec3 horizontal;
    vec3 vertical;
    mat4 matrix;
}
cam;
layout(binding = 2) buffer Random { float random_source[]; };
layout(binding = 3) uniform RenderSettings
{
    int max_bounces;
    int aa;
}
render_settings;
ivec2 dim = imageSize(result_image);
float aspect = float(dim.x) / float(dim.y);

#include "structs.glsl"

layout(std430, binding = 4) buffer Spheres { Sphere spheres[]; };
layout(std430, binding = 5) buffer Triangles { Triangle triangles[]; };
layout(std430, binding = 6) buffer Materials { Material materials[]; };

#include "util.glsl"
#include "intersection.glsl"
#include "material.glsl"

bool colour(inout Ray ray, inout Record record)
{
    record.distance = -1;
    bool intersected = intersect_spheres(ray, record);
    intersected = intersect_triangles(ray, record) || intersected;

    if (intersected)
    {
        apply_record(ray, record);
        return true;
    }
    else
    {
        record.albedo = vec3(0);
//        record.emission = mix(vec3(0.9, 0.9, 1), vec3(.6, 0.6, 1), (ray.direction.y - 0.5) * 2);
        record.emission = vec3(0);
        record.reflectiveness = 0.0;
        return false;
    }
}

vec3 trace(in Ray ray)
{
    vec3 throughput = vec3(1);
    vec3 final = vec3(0);

    Record record;
    for (int i = 0; i < render_settings.max_bounces; i++)
    {
        if (!colour(ray, record))
        {
            final += throughput * record.emission;
            break;
        }
        final += throughput * record.emission;
        throughput *= record.albedo * record.reflectiveness;
    }

    return final;
}

void main()
{
    vec3 sampled = vec3(0);

    for (int i = 0; i < render_settings.aa; i++)
    {
        vec2 coord = ((vec2(gl_GlobalInvocationID.xy) + vec2(rand(), rand())) / dim) * 2.0 - 1;
        Ray ray = get_ray(coord);
        sampled += trace(ray);
    }

    imageStore(result_image, ivec2(gl_GlobalInvocationID.xy),
               vec4((sampled / render_settings.aa), 0));
}
