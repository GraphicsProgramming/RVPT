#version 450
#extension GL_GOOGLE_include_directive : require

#define RAY_MIN_DIST 0.01

layout(local_size_x = 16, local_size_y = 16) in;
layout(binding = 0, rgba8) uniform writeonly image2D result_image;
layout(binding = 1) uniform Camera {vec3 origin; vec3 center; vec3 horizontal; vec3 vertical; } cam;

#include "structs.glsl"
#include "util.glsl"

// Global Variables //
ivec2 dim = imageSize(result_image);
float aspect = float(dim.x) / float(dim.y);
Sphere[1] spheres;
// End Global Variables //

bool intersect_spheres(Ray ray, inout Record record)
{
    for (int i = 0; i < spheres.length(); i++)
    {
        vec3 oc = ray.origin - spheres[i].origin;
        float b = dot(oc, ray.direction);
        float c = dot(oc, oc) - spheres[i].radius * spheres[i].radius;
        float delta = b * b - c;

        if (delta > 0.0f)
        {
            delta = sqrt(delta);
            float t0 = (-b - delta);
            float t1 = (-b + delta);
            float distance = min(t0, t1);
            if (!(t0 < 0 || t1 < 0) && RAY_MIN_DIST < distance)
            {
                record.hit = true;
                record.distance = distance;
                record.intersection = ray.origin + ray.direction * distance;
                record.normal = normalize(record.intersection - spheres[i].origin);
                return true;
            }
        }
    }

    return false;
}

bool colour(inout Ray ray, inout Record record)
{
    if (intersect_spheres(ray, record))
    {
        record.albedo = vec3(1);
        record.emission = vec3(0);
        record.reflectiveness = 1;
        ray.origin = record.intersection;
        ray.direction = reflect(ray.direction, record.normal);
        return true;
    }
    else
    {
        record.albedo = vec3(0);
        record.emission = mix(vec3(0.9, 0.9, 1), vec3(.6, 0.6, 1), (ray.direction.y - 0.5) * 2);
        record.reflectiveness = 0.0;
        return false;
    }
}

vec3 trace(in Ray ray)
{
    vec3 throughput = vec3(1);
    vec3 final = vec3(0);

    Record record;
    for(int i=0; i<3; i++)
    {
        if (!colour(ray, record))
        {
            final += throughput * record.emission;
            break;
        }
        final += throughput * record.emission;
        throughput *= record.albedo * record.reflectiveness;
    }

    return final;
}

void main()
{
    // Setup Scene //
    spheres[0] = Sphere(vec3(0.0f, 0.0f, -10.0f), 1.0f);
    // End Scene Setup //

    vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;
    vec2 ndc = uv * 2.0f - 1.0f;
    Ray ray = get_ray(ndc);

    vec4 final_color = vec4(trace(ray), 0);

    imageStore(result_image, ivec2(gl_GlobalInvocationID.xy), final_color);
}
